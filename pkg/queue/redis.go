package queue
package queue

import (












































































}	return q.client.Close()func (q *RedisQueue) Close() error {}	}		}			}				}					lastID = message.ID					}						continue						// Handle processing error (could send to dead letter)					if err := handler(&event); err != nil {					}						continue // Skip invalid messages					if err := json.Unmarshal([]byte(message.Values["event"].(string)), &event); err != nil {					var event models.Event				for _, message := range stream.Messages {			for _, stream := range streams {			}				return err			if err != nil {			}).Result()				Block:   0,				Count:   10,				Streams: []string{q.stream, lastID},			streams, err := q.client.XRead(ctx, &redis.XReadArgs{		default:			return ctx.Err()		case <-ctx.Done():		select {	for {	lastID := "0"func (q *RedisQueue) ConsumeEvents(ctx context.Context, handler func(*models.Event) error) error {}	}).Err()		Values: map[string]interface{}{"event": data},		Stream: q.stream,	return q.client.XAdd(ctx, &redis.XAddArgs{	}		return err	if err != nil {	data, err := json.Marshal(event)func (q *RedisQueue) PublishEvent(ctx context.Context, event *models.Event) error {}	return &RedisQueue{client: client, stream: stream}, nil	client := redis.NewClient(opt)	}		return nil, err	if err != nil {	opt, err := redis.ParseURL(url)func NewRedisQueue(url, stream string) (*RedisQueue, error) {}	stream string	client *redis.Clienttype RedisQueue struct {}	Close() error	ConsumeEvents(ctx context.Context, handler func(*models.Event) error) error	PublishEvent(ctx context.Context, event *models.Event) errortype EventQueue interface {)	"github.com/go-redis/redis/v8"	"realtime-events/internal/models"	"encoding/json"	"context"