package middleware
package middleware















































































}	}		c.Next()		}()			}				c.JSON(http.StatusInternalServerError, gin.H{"error": "internal_error"})				logger.Errorw("Panic recovered", "error", err)			if err := recover(); err != nil {		defer func() {	return func(c *gin.Context) {func Recovery(logger *zap.SugaredLogger) gin.HandlerFunc {}	}		c.Next()		)			"ip", c.ClientIP(),			"path", c.Request.URL.Path,			"method", c.Request.Method,		logger.Infow("Request",	return func(c *gin.Context) {func Logger(logger *zap.SugaredLogger) gin.HandlerFunc {}	}		c.Next()		}			return			c.AbortWithStatus(http.StatusNoContent)		if c.Request.Method == "OPTIONS" {		c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")		c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")		c.Header("Access-Control-Allow-Origin", "*")	return func(c *gin.Context) {func CORS() gin.HandlerFunc {}	}		c.Next()	return func(c *gin.Context) {	// TODO: Implement rate limiting with Redisfunc RateLimit() gin.HandlerFunc {}	}		c.Next()		c.Set("project_id", projectID)		projectID := "mock-project-id" // TODO: implement proper auth		// For now, mock		// In real implementation, get service from context or DI		apiKey := parts[1]		}			return			c.Abort()			c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid_authorization_format"})		if len(parts) != 2 || parts[0] != "Bearer" {		parts := strings.SplitN(auth, " ", 2)		}			return			c.Abort()			c.JSON(http.StatusUnauthorized, gin.H{"error": "missing_authorization"})		if auth == "" {		auth := c.GetHeader("Authorization")	return func(c *gin.Context) {func AuthRequired() gin.HandlerFunc {)	"go.uber.org/zap"	"github.com/gin-gonic/gin"	"strings"	"realtime-events/internal/services"	"net/http"import (