package handlers
package handlers













































































































}	return net.ParseIP(ip)	}		return net.ParseIP("127.0.0.1")	if err != nil {	ip, _, err := net.SplitHostPort(c.Request.RemoteAddr)	// Fallback to remote address	}		}			return ip		if ip := net.ParseIP(xri); ip != nil {	if xri != "" {	xri := c.GetHeader("X-Real-IP")	// Check X-Real-IP header	}		}			}				return ip			if ip := net.ParseIP(strings.TrimSpace(ips[0])); ip != nil {		if len(ips) > 0 {		ips := strings.Split(xff, ",")	if xff != "" {	xff := c.GetHeader("X-Forwarded-For")	// Check X-Forwarded-For headerfunc getClientIP(c *gin.Context) net.IP {}	})		"status":    "accepted",		"event_ids": events,	c.JSON(http.StatusAccepted, gin.H{	}		events = append(events, event.ID)		}			continue // Continue processing other events			h.logger.Errorw("Failed to process batch event", "error", err)		if err != nil {		event, err := h.service.ProcessEvent(c.Request.Context(), &eventReq, projectID.(string), ip, userAgent)	for _, eventReq := range req.Events {	events := make([]string, 0, len(req.Events))	userAgent := c.GetHeader("User-Agent")	ip := getClientIP(c)	}		return		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})	if !exists {	projectID, exists := c.Get("project_id")	}		return		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_request", "message": err.Error()})	if err := c.ShouldBindJSON(&req); err != nil {	var req models.BatchEventRequestfunc (h *EventHandler) IngestBatchEvents(c *gin.Context) {}	})		"status":   "accepted",		"event_id": event.ID,	c.JSON(http.StatusAccepted, gin.H{	}		return		c.JSON(http.StatusInternalServerError, gin.H{"error": "internal_error"})		h.logger.Errorw("Failed to process event", "error", err)	if err != nil {	event, err := h.service.ProcessEvent(c.Request.Context(), &req, projectID.(string), ip, userAgent)	userAgent := c.GetHeader("User-Agent")	ip := getClientIP(c)	}		return		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})	if !exists {	projectID, exists := c.Get("project_id")	}		return		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid_request", "message": err.Error()})		h.logger.Errorw("Invalid request", "error", err)	if err := c.ShouldBindJSON(&req); err != nil {	var req models.EventRequestfunc (h *EventHandler) IngestEvent(c *gin.Context) {}	return &EventHandler{service: service, logger: logger}func NewEventHandler(service *services.EventService, logger *zap.SugaredLogger) *EventHandler {}	logger  *zap.SugaredLogger	service *services.EventServicetype EventHandler struct {)	"go.uber.org/zap"	"github.com/gin-gonic/gin"	"strings"	"realtime-events/internal/services"	"realtime-events/internal/models"	"net/http"	"net"import (