package ingestion
package main

import (











































































































}	sugar.Info("Server exited")	}		sugar.Fatalw("Server forced to shutdown", "error", err)	if err := srv.Shutdown(ctx); err != nil {	defer cancel()	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)	// Context for graceful shutdown	sugar.Info("Shutting down server...")	<-quit	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)	quit := make(chan os.Signal, 1)	// Wait for interrupt signal	}()		}			sugar.Fatalw("Failed to start server", "error", err)		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {		sugar.Infow("Starting server", "port", cfg.Port)	go func() {	// Graceful shutdown	}		Handler: router,		Addr:    ":" + cfg.Port,	srv := &http.Server{	// Start server	}		v1.POST("/events/batch", eventHandler.IngestBatchEvents)		v1.POST("/events", eventHandler.IngestEvent)	{	v1.Use(middleware.AuthRequired())	v1 := router.Group("/api/v1")	// API routes	router.GET("/metrics", observability.MetricsHandler())	// Metrics	})		c.JSON(http.StatusOK, gin.H{"status": "healthy"})	router.GET("/health", func(c *gin.Context) {	// Health check	router.Use(middleware.CORS())	router.Use(middleware.RateLimit())	router.Use(middleware.Recovery(sugar))	router.Use(middleware.Logger(sugar))	// Middleware	router := gin.New()	gin.SetMode(gin.ReleaseMode)	// Setup Gin router	eventHandler := handlers.NewEventHandler(eventService, sugar)	// Initialize handlers	eventService := services.NewEventService(db, eventQueue, sugar)	// Initialize services	defer eventQueue.Close()	}		sugar.Fatalw("Failed to connect to queue", "error", err)	if err != nil {	eventQueue, err := queue.NewRedisQueue(cfg.RedisURL, "events")	// Initialize queue	defer db.Close()	}		sugar.Fatalw("Failed to connect to database", "error", err)	if err != nil {	db, err := storage.NewPostgres(cfg.DatabaseURL)	// Initialize storage	}		sugar.Fatalw("Failed to load config", "error", err)	if err != nil {	cfg, err := config.Load()	// Load configuration	sugar := logger.Sugar()	defer logger.Sync()	logger, _ := zap.NewProduction()	// Initialize loggerfunc main() {)	"realtime-events/pkg/storage"	"realtime-events/pkg/queue"	"realtime-events/internal/services"	"realtime-events/internal/observability"	"realtime-events/internal/middleware"	"realtime-events/internal/config"	"realtime-events/internal/api/handlers"	"go.uber.org/zap"	"github.com/gin-gonic/gin"	"time"	"syscall"	"os/signal"	"os"	"net/http"	"log"	"context"